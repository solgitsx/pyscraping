#!/usr/bin/env python
# coding: utf-8

# # 5장 데이터 처리와 분석을 위한 라이브러리

# ## 5.1 배열 데이터 연산에 효율적인 넘파이(NumPy)

# ### 5.1.1 배열 데이터 생성

# #### 리스트 데이터로부터 배열을 생성

# [5장: 146페이지]

# In[ ]:


# ### 5.1.2 배열 데이터 선택

# #### 배열의 인덱싱

# [5장: 150페이지]

# In[ ]:


import numpy as np

l1 = [0, 10, 20, 30, 40, 50] # 리스트
print([l1[0], l1[3], l1[5], l1[-1], l1[-2]])  # 리스트 인덱싱의 다양한 예


a1 = np.array(l1) # 1차원 배열 생성
# 값을 참조
print([a1[0], a1[3], a1[5], a1[-1], a1[-2]])  # 배열 인덱싱의 다양한 예


# In[ ]:


# 값을 변경
a1[4] = 90
a1


# In[ ]:


a2 = np.array([0, 10, 20, 30, 40, 50]) # 1차원 배열 생성

# 배열의 위치로 여러 개의 요소를 선택
a2[[4, 0, 5, -1, -2]] # array([40,  0, 50, 50, 40])

# 에러 : 리스트로 주지 않고 여러 요소를 선택할 수 없다.
# a2[4, 0, 5, -1, -2] # IndexError: too many indices for array: array is 1-dimensional, but 5 were indexed



#%%
# [5장: 151페이지]

# In[ ]:


a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
a


# In[ ]:


# 조건 선택 : 참조
print(a[a >= 5]) # [5 6 7 8 9]

# 원본은 변하지 않음
print(a) # [0 1 2 3 4 5 6 7 8 9]


# In[ ]:


# 짝수 값을 선택
a[(a % 2) == 0]


# In[ ]:

# 두 조건을 동시에 만족하는 요소만 선택
# 짝수이면서 5보다 큰 값을 선택
a[ ((a % 2)==0) & (a > 5) ]  # array([6, 8])

#%%

# ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
# a[ ((a % 2)==0) and (a > 5) ]  # array([6, 8])

x = 10
if ((x % 2)==0) and (x > 5):
    print(True)

#%%

x = 10
y = ((x % 2)==0) & (x > 5)
print('y=', y)
if ((x % 2)==0) & (x > 5):
    print(True)

#%%

# 비트 연산 : binary 연산
z = 10 & 11
print("z=", z) # 10

print((True & True)) # True

t = True
f = False
print('t=', t, int(t)) # True, 1
print('f=', f, int(f)) # False, 0

print("& : ", (int(t) & int(f))) # 0
print("| : ", (int(t) | int(f))) # 1
print("~0 : ", ~(int(t) & int(f))) # 0 -> -1

print("~1 : ", ~(1)) # -2

#%%
"""
# 마이너스는 2의 보수
10  : 1010
 3  : 0011
 2  : 0010
 1  : 0001
 0  : 0000
-1  : 1111
-2  : 1110
-3  : 1101
-10 : ?
--------------------------------
# 1과 2의 보수
1과 -1
 1 : 0001
-1 : 1110   # 1의 보수
        1   # 1의 보수에 1을 더하면 2의 보수
   -------
-1 : 1111   # 2의 보수
--------------------------------
# 10을 2의 보수를 사용하여 -10을 만들어라.
 10 : 0000 1010
-10 : 1111 0101
              1 
---------------
-10 : 1111 0110         

"""

# b10 = int("0b11110110", 2)
b10 = bin(-10)
print("b10=", b10) # -0b1010


# In[ ]:

# or 조건
a[ ((a % 2)==0) | (a > 5) ] # 두 조건 중 하나만 만족해도 요소 선택


# In[ ]:


# 짝수가 아닌 값 선택
a[ ~((a % 2)==0) ] # 짝수를 찾는 조건의 논리 부정을 이용해 홀수 선택


#%%
# #### 배열의 슬라이싱

# [5장: 152페이지]

# In[ ]:


import numpy as np

a1 = np.array([0, 10, 20, 30, 40, 50]) # 1차원 배열 생성

# start, end를 모두 지정해 슬라이싱. 선택 범위: start ~ end-1
a1[1:4] # array([10, 20, 30])


# In[ ]:


# end만 지정해 슬라이싱. 선택 범위: 0 ~ end-1
a1[:3] # array([ 0, 10, 20])


# In[ ]:


# start만 지정해 슬라이싱. 선택 범위: start ~ 배열의_마지막_위치
a1[2:] # array([20, 30, 40, 50])


# In[ ]:

# start, end 모두 지정하지 않으면 배열 전체가 선택됨
a1[:] # array([ 0, 10, 20, 30, 40, 50])

#%%

# [5장: 153페이지]

# In[ ]:

    
# 선택한 위치(2, 3, 4)의 요소를 새로운 배열로 변경
print(a1) # [ 0 10 25 35 45 50]
# [0, 10, ?, ?, ?, 50]
a1[2:5] = np.array([25, 35, 45]) 
a1

#%%

# 리스트 : 슬라이스 범위에 값을 지정
lst = [ 0, 10, 25, 35, 45, 50]
lst[2:5] = [77, 88, 99]
print(lst)

#%%
# 리스트 : 슬라이스 범위에 값을 지정(넘파이)
lst = [ 0, 10, 25, 35, 45, 50]
lst[2:5] = np.array([77, 88, 99])
print(lst)

# In[ ]:

# 선택한 위치(3, 4, 5)의 요소를 모두 스칼라 값으로 변경
a1[3:6] = 70 
a1


# In[ ]:


a2 = np.array([0, 10, 20, 30, 40, 50, 60, 70, 80, 90]) # 1차원 배열 생성

# 선택 범위: start~end-1, 증가폭(step): 2                             
a2[0:10:2] # array([ 0, 20, 40, 60, 80])

# In[ ]:

# 선택 범위: start ~ end-1, 증가폭(step): 3
a2[2:8:3] # array([20, 50])


# In[ ]:

# 선택 범위: start ~ end-1, 증가폭(step): 1
a2[0:10:] # array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])


# [5장: 154페이지]

# In[ ]:

# 선택 범위: start~배열의_마지막_위치, 증가폭(step): 1
a2[3::] # array([30, 40, 50, 60, 70, 80, 90])


# In[ ]:

# 선택 범위: 0~end-1, 증가폭(step): 1
a2[:5:] # array([ 0, 10, 20, 30, 40])


# In[ ]:

# 선택 범위: 0 ~ 배열의_마지막_위치, 증가폭(step): 1
a2[::] # array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])


# In[ ]:

# 선택 범위: 배열의_마지막_위치~0, 증가폭(step): -1 -> 역순으로 선택
a2[::-1] # array([90, 80, 70, 60, 50, 40, 30, 20, 10,  0])


# In[ ]:

# 증가폭(step): -2 -> 역순으로 선택
a2[8:2:-2] # array([80, 60, 40])

#%%
a2[0::-2] # array([0])

#%%
a2 # array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
a2[6::-2] # array([60, 40, 20,  0])

#%%

# 0번째는 포함되지 않음
a2[6:0:-2] # array([60, 40, 20])
